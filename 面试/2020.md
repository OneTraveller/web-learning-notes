# 2020 年面试准备

## html 相关

### 什么是 html

超文本标记语言，一个网页文件

### HTML XHTML DHTML XML 的区别

HTML: 专门编写网页内容的语言
XHTML: 只是更严格的 HTML 语言标准
DHTML: 一切实现动态网页效果的技术的统称
XML: 专门存储结构化数据的标记语言，语法同 HTML,只是可自定义标签名

### DOCTYPE 有什么作用

告诉浏览器使用哪个版本的 HTML 规范来渲染文档
如果不加 doctype，浏览器根据自己的模式解析文档，为怪异模式

### html5 的新特性

1. 添加语义标签 header footer
2. 增强型表单 placeholder required
3. 视频和音频
4. canvas 绘图
5. svg 绘图
6. 地理定位
7. 拖放 api
8. web storage
9. websocket
10. web worker

### 简述一下 src 与 href 的区别

1. href 是指向网络资源所在位置，建立和当前文档之间的链接，用于超链接。
2. src 是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。

### meta 有哪些属性，作用是什么

<meta> 标签提供了 HTML 文档的元数据。元数据不会显示在客户端，但是会被浏览器解析。
META元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者及其他元数据。
元数据可以被使用浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 Web 服务调用。

1. charset：定义 HTML 定义文档的字符编码
<meta charset="UTF-8" />

2. content： 定义与 http-equiv 或 name 属性相关的元信息。

3. name: 把 content 属性关联到一个名称。
   可选值：application-name、author、description、generator、keywords

4. viewport：视口，用于控制页面宽高及缩放比例
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

viewport 参数说明

- width/height，宽高，默认宽度 980px
- initial-scale，初始缩放比例，1~10
- maximum-scale/minimum-scale，允许用户缩放的最大/小比例
- user-scalable，用户是否可以缩放 (yes/no)

5. http-equiv：把 content 属性关联到 HTTP 头部，可设置过期时间、缓存、刷新

```
<meta http-equiv="Pragma" content="no-cache"/> // 设置无缓存
<meta http-equiv="Cache-Control" content="no-cache"/> // 设置无缓存
<meta http-equiv="Expires" content="0"/> // 指定过期时间
<meta http-equiv="refresh" content="30"> // 每 30 秒刷新页面
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> // 使用浏览器版本
<meta http-equiv="content-type" content="text/html; charset=UTF-8"> // 规定文档的字符编码
<meta http-equiv="content-language" content="en-US"> // 使用语言
<meta http-equiv="Set-Cookie" content = "cookievalue=xxx;expires=Wed,10 Apr 2017 16:44:59 GMT;path=/" /> // 设置cookie
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"/> // 可利用http-equiv将http请求换成https请求
```

## css 相关

### 什么是 css

1. CSS 是层叠样式表 ( Cascading Style Sheets ) 的简称。
2. CSS 是一种标记语言，属于浏览器解释型语言，可以直接由浏览器执行，不需要编译。
3. CSS 是用来表现 HTML 或 XML 的标记语言。
4. CSS 是由 W3C 的 CSS 工作组发布推荐和维护的.
5. 运用 CSS 样式可以让页面变得美观。
6. CSS 语法由三部分构成：选择器、属性和值： selector {property: value}

### 使用 CSS 的优势

1. 实现内容与样式分离。
2. 提高代码的可重用性和可维护性。

### 如何使用 CSS？

有三种方法可以在站点网页上使用样式表：

1. 外联式 Linking（也叫外部样式）：将网页链接到外部样式表。
2. 内部样式表：将样式定义在 head 元素中的 style 元素中。
3. 内联方式：应用内嵌样式到各个网页元素。
   其中，优先级：内联方式 > 内部样式表 > 外联式

### 伪类选择器 和 伪元素选择器

伪类选择器
简介：逻辑上和功能上和类相似，但是不存在于文档树中且表达方式也不同，所以叫伪类
作用：匹配元素不同状态时的样式

- :link 适用于尚未访问的超链接
- :visited 适用于访问过的超链接
- :active 适用于元素被激活时的状态
- :hover 适用于鼠标悬停在 HTML 元素时
- :focus 适用于 html 元素获取焦点时的状态(text,password)
- :first-child 匹配兄弟元素中的第一个元素。
- :last-child 匹配兄弟元素中最末的那个元素。

伪元素选择器
简介：匹配元素的内容，在文档树中不存在，所以称为伪元素
作用：操作元素的文本和添加内容

- ::after 匹配出现在原有元素的实际内容之后的一个可样式化元素。
- ::before 匹配出现在原有元素的实际内容之前的一个可样式化元素。
- ::first-letter 匹配元素的第一个字母。
- ::first-line 匹配包含此伪元素的元素的第一行。
- ::grammar-error 匹配文档中包含了浏览器标记的语法错误的那部分。
- ::selection 匹配文档中被选择的那部分。
- ::spelling-error 匹配文档中包含了浏览器标记的拼写错误的那部分。

出处[出处](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements)

### 优先级列表

- important：无穷大
- 内联样式：1000
- id 选择器：100
- 类选择器/属性选择器/伪类选择器：10
- 标签选择器/伪元素选择器：1

### css3 的新特性

1. 动画 animation
2. 过渡 transition
3. 多媒体查询
4. 多背景图
5. 阴影
6. 圆角
7. 渐变
8. 字体 @font-face
9. 转换 （旋转 缩放）
10. flex

### 盒子模型

盒子模型包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分

### 清除浮动

1. 设置父元素 overflow 属性为 hidden
2. 使用 clear：both
3. 在浮动元素后面添加一个空标签
4. 使用伪元素：after

### 块级元素 与 行内元素

行内元素：

1. 行内元素可以多个并排在同一行
2. 无法设置宽高，默认宽高是文字宽度

块级元素：

1. 每个块级元素独占一行，不能与任何其他元素并列一行
2. 可以设置宽高， 不设置宽高就默认占父级元素 100%宽高

行内元素转换为块级元素

1. float：把行内元素设置为 float:left/right
2. position：position:absolute 与 position:fixed
3. 设置 display：block;

### px，em，rem 的区别

px 像素 相对长度单位。像素 px 是相对于显示器屏幕分辨率而言的 em 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。
rem 也是相对长度单位，但相对的是 HTML 根元素。只修改根元素就成比例地调整所有字体大小

移动端设置字体

1. rem + vw
2. 用媒体查询设置最大宽度和最小宽度 max-width: 768px; min-width: 320px;

```
html {
  font-size: calc(100vw / 7.5);
}
div {
  font-size: 0.32rem;
}
```

### 动画

1. 用 keyframes 创建动画

```
@keyframes myfirst {
  0% {background:red;}
  100% {background:yellow;}
}
```

2. 用 animation 绑定到某个选择器，设置名称和时长

```
div {
  width:100px;
  height:100px;
  background:red;
  animation:myfirst 5s;
}
```

3. steps()
   steps()可以让动画不连续，作为动画的第三个参数使用

### transition 和 transform

> 这两个属性自己容易搞混，记一下

transform 是转换，指的是改变所在元素的外观，它有很多种手段(转换函数)来改变外观，例如 位移、缩放、旋转 等。
transform: [转换函数];
transform: translate(10px, 10px) rotate(10deg);

transition 是过渡，指的是某个 CSS 属性值如何平滑的进行改变，就是平常说的 动效。而 transform 是没有动画效果。
transition: [属性名][持续时间] [速度曲线][延迟时间];
给多个属性指定多个过渡: transition: height 2s, width 3s;

transition + transform

```
.box {
  width: 100px;
  height: 100px;
  transition: all 0.4s ease;
}

.box:hover {
  transform: scale(1.2, 1.2);
}
```

### transition 与 animation 的区别

transition: property duration timing-function delay;
animation: name duration timing-function delay iteration-count direction;

区别：

1. animation 多两个参数(循环和动画方式)
2. transition 不能自行触发，通过 hover 等动作，或者结合 js 进行触发。animation 可以自行运行
3. transition 可控性相对较弱，只能够指定起始和结束的状态，而 animation 可以定义多个关键帧
4. 动画在运行结束之后，需要回到初始状态
5. transition 的作用，可以用一句话来概括“平滑改变 CSS 值”

### 垂直居中几种方式

1. display: flex

```
.outer {
  display: flex;
  align-items: center;
  justify-content: center;
}
```

2. absolute + transform

```
.outer {
  position: relative;
}
.inner {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```

3. absolute + margin: auto

```
.outer {
  position: relative;
}
.inner {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  margin: auto;
}
```

### 常见圣杯布局

```
body {
  display: flex;
  padding: 0;
  margin: 0;
}
.left {
  background: blue;
  flex: 200px 0 0;
}
.middle {
  background: red;
  flex: 1;
}
.right {
  background: green;
  flex: 0 0 200px;
}
```

### 隐藏元素的几种方法

1. 设置 display: none;
2. 设置 visibillity: hidden;
3. 设置 opacity: 0;

### 重绘和回流，怎么避免回流

1. 如果同时创建父元素和子元素时，建议在内存中先将子元素添加到父元素，再将父元素一次性挂到页面
2. 如果只添加多个平级子元素时, 就要将所有子元素，临时添加到文档片段中。再将文档片段整体添加到页面
   文档片段: 内存中，临时保存多个平级子元素的 虚拟父元素
   用法和普通父元素完全一样
   如何: 3 步:
   1. 创建片段:
      var frag=document.createDocumentFragment();
   2. 将子元素临时追加到 frag 中:
      frag.appendChild(child);
   3. 将 frag 追加到页面:
      parent.appendChild(frag);
      强调: append 之后，frag 自动释放，不会占用元素

### flex 相关

#### 介绍 flex

Flex 是 Flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。
设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。

#### flex: 1;指的是什么

flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。
flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小
flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。

flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。
当 flex 取值为 none，则计算值为 0 0 auto
当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%
当 flex 取值为一个长度或百分比或 auto，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1
当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%
当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1

flex: 1; === flex-grow: 1; flex-shrink: 1; flex-basis: 0%;

#### 九宫格的实现

```
.flex {
  display: flex;
  width: 100px;
  height: 100px;
  border: 1px solid;
  flex-wrap: wrap;
}
.flex .item {
  width: calc(100% / 3);
  box-sizing: border-box;
  border: 1px solid;
}
```

## js 相关

### 简介

Javascript 是一种运行于 JS 解释器/引擎 中的解释型脚本语言

JS 解释器/引擎 ：JS 运行环境（PC 机，手机，平板）
1、独立安装的解释器 NodeJS
2、浏览器内核中嵌入的 JS 解释器

### 基本类型和引用类型

基本类型：

1. 类型：number string undefined null boolean
2. 基本类型的值是不可变得
3. 基本类型的比较是值的比较
4. 基本类型的变量是存放在栈内存的

引用类型：

1. 引用类型的值是可变的
2. 引用类型值可添加属性和方法
3. 引用类型的比较是引用地址的比较
4. 引用类型存储的是地址（指针）。当你创建了一个引用类型的时候，计算机会在堆内存中帮我们开辟一个空间来存放值，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址。复制对象时，会在栈内存中添加一个指针，跟被复制的指针指向堆内存中相同的一个值，所以修改其中一个对象，另一个都会受到影响

检测对象类型

```
Object.prototype.toString.call(obj).slice(8, -1)
Object.prototype.toString.call({}).slice(8, -1); // Object
Object.prototype.toString.call('').slice(8, -1); // String
```

### 字符串

#### 简介

表示 一系列的文本字符的数据，由 Unicode 字符、数字、标点来组成，必须使用 "" 或 '' 引起来数据
汉字的范围： \u4E00 ~ \u9FA5

#### 字符串常用方法

1. slice(start, [end]) // 截取字符串
2. substring(start, [stop]) // 截取字符串， 与 slice 相似，但不允许负的参数；如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。
3. substr(start, length) // 截取字符串
4. charAt() // 返回在指定位置的字符
5. concat() //拼接字符串
6. indexOf() // 检索字符串
7. lastIndexOf() // 从后向前检索
8. match() // 找到与正则的匹配 ('match1match2').match(/\d+/g) => [1,2];
9. replace() // 替换与正则相匹配的值 ('match1match2').replace(/\d/g, '||') => ('match||match||')
10. search() // 检索与正则匹配的值 ('match1match2').search(/\d/g) => 5
11. toUpperCase() // 把字符串转为大写
12. toLowerCase() // 把字符串转为小写
13. split('&') 字符串按‘&’进行分割

#### String 和 toString

String: 万能
toString：在转换 null 和 undefined 时会报错

### 数字

表示 32 位的整数 也可以表示 64 位的浮点数

#### 0.1 + 0.2 为什么不等于 0.3

因为计算机浮点数转换为二进制时，不能精确表示 0.1， 0.2 这样的浮点数，计算时使用的是带有舍入误差的数。
解决方式：转换为整数后计算

### Boolean

仅有两个值：true 和 false
做算术运算时，true = 1，false=0

### undefined

1、声明变量未赋值
2、对象属性不存在
3、未提供的函数参数
4、没有 return 的函数返回值

### null

null 是 JavaScript 中的一个关键字，表示没有值或者是任何值都不存在。可以设置为 null 来清空对象

typeof null 为什么等于 object
原理是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“ object ”。100：字符串，数据是字符串。110：布尔类型，数据是布尔值。

### 对象

#### 对象常用方法

1. Object.keys 获取对象的所有 keys 值 为数组形式
2. Object.values 获取对象的所有 values 为数组形式
3. {}.hasOwnproperty('key') 判断对象是否有 key 属性
4. for(let x in obj) 循环对象
5. Object.assign() 复制并克隆对象,并返回合并后的对象，如果是多个对象参数，那么相同的属性，后边的属性值会覆盖前边的属性值；例如 Object.assign({} , obj)
6. Object.entries() 遍历对象，并返回一个数组，数组的每一个元素是由对象的属性以及属性值组成的数组；
7. Object.create() 创建对象
8. obj.hasOwnProperty('name') 判断对象自身属性中是否具有指定的属性。

#### 原型与原型链

- 原型是一个普通的对象，原型对象是构造函数的一个实例，主要用于继承。
- 在创建对象的时候，都有一个叫做**proto** 的内置属性，用于指向创建它的构造函数的原型对象，**proto** 将对象和原型连接起来组成了原型链
- 对象拥有这样一个原型链以后，当访问对象的属性时，先查找自身是否有该属性，当找不到该属性时，该对象就沿着原型链依次去查找，找不到返回 undefined
- Object.prototype.**proto** 是 null，表示 obj 对象原型链的终结
- 在原型对象上定义方法和属性，是为了被子类继承和使用
- Object 是所有对象的爸爸，所有对象都可以通过 **proto** 找到它
- Function 是所有函数的爸爸，所有函数都可以通过 **proto** 找到它

#### 继承

1. 原型链继承

```
function Parent() {
  this.name = 'mike';
}
function Child() {
  this.age = 12;
}
Child.prototype = new Parent();
var child = new Child();
alert(child.name) // 'mike'
```

2. 原型式继承

```
function obj(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
var box = {
  name: 'trigkit4',
  arr: ['brother', 'sister', 'baba'],
};
var b1 = obj(box);
alert(b1.name); //trigkit4;
```

#### 浅拷贝和深拷贝

浅拷贝: 只解决了第一层的问题，如果接下去的值中还有对象的话，两者享有相同的地址，会相互影响

```
let a = {
  age: 1,
};
let b = Object.assign({}, a); // 或者 let b = { ...a }
```

深拷贝

1. JSON.parse(JSON.stringify(object))

缺陷：

- 会忽略 undefined
- 会忽略 symbol
- 不能序列化函数
- 不能解决循环引用的对象

2. 递归

```
function deepCopy(params) {
  var obj;
  if (typeof params === 'object') {
    if (Array.isArray(params)) {
      obj = [];
      for (var i = 0; i < params.length; i++) {
        obj.push(arguments.callee(params[i]))
      }
    } else {
      obj = {};
      for (var c in params) {
        obj[c] = arguments.callee(params[c]);
      }
    }
  } else { return params; }
  return obj;
}
```

### 数组

#### 简介

数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。

#### 数组常用方法

1.  concat() //连接多个数组，并返回结果
2.  join() //把数组分割成字符串 如[1,2].join(',') => "1,2"
3.  pop() // 删除并返回数组的最后一个元素
4.  pusp() //向数组的末尾添加一个或更多元素，并返回新的长度
5.  unshift() //向数组的开头添加一个或更多元素，并返回新的长度
6.  shift() // 删除并返回数组的第一个元素
7.  sort() // 对数组进行排序
8.  reverse() // 颠倒数组
9.  toString() // 把数组转为字符串
10. slice(start, [end]) // 返回数组指定元素
11. splice(index, count, [add]) // 从数组中删除指定元素，并返回被删除内容(数组格式) index: 位置；count：删除数量；add：添加元素 可选
12. map filter forEach reduce find some every includes

#### 手写排序

### 函数

#### 简介

函数(function)，也可以被称之为方法(method)，是一段预定义好（事先声明好，但不被执行），并可以被反复使用的代码块。其中可以包含多条可执行语句。
函数声明语句
function funcname([arg1[, arg2[..., argn]]]) { statements }
函数定义表达式
var square = function(x) { return x + x; }

#### 作用域链和闭包

作用域
作用域就是变量或函数的可访问范围。它控制着变量或函数的可见性和生命周期。分为局部作用域和全局作用域

作用域链

- 作用域分为全局作用域和局部作用域，全局作用域在代码中的任何地方都可以被访问，局部作用域只在固定的代码片段中可以访问到。
- 每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。作用域链是函数被创建的作用域中对象的集合。作用域链可以保证对执行环境有权访问的所有变量和函数的有序访问。标识符解析是沿着作用域一级一级的向上搜索标识符的过程，直到找到标识符（找不到报错）。
- 先用局部作用域的，如果没有，才去全局作用域找
- 作用域优先级：变量 > 普通函数 > 参数 > 提升

闭包
函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。
优点：当全局变量使用，避免全局污染
缺点：容易造成内存泄漏

### 正则

正则：也叫做规则，让计算机能够读懂人类的规则
　　 1）常用方法
　　　　 String 对的方法
　　　　　　 str.search(/表达式/) 返回匹配到的第一个位置
　　　　　　 str.split(/表达式/)
　　　　　　 str.match(/表达式/)
　　　　　　 str.replace(/表达式/,'')
　　　　 RegExp 对象方法
　　　　　　/表达式/.test(str) 返回布尔值
　　　　　　/表达式/.exec(str) 返回一个数组，存放匹配的结果，如果未找到匹配，则返回值为 null
　　 2）匹配手机号、邮箱、汉字、千分位
　　　　验证手机号：/^1[345789]\d{9}/.test('15662173333')
　　　　验证邮箱：/^\w+@[a-z0-9]+\.[a-z]+$/i
　　　　验证汉字：^[\u4e00-\u9fa5],{0,}$
　　　　实现千分位：/\B(?=(\d{3})+(?!\d))/g

### typeof 和 instanceof 的区别

typeo

1. 检测变量是字符串、数值、布尔值还是 undefined 的最佳工具。
2. typeof 来获取一个变量是否存在比较安全，如果要去使用 if 判断（未声明）则会出错。

instanceof

1. instanceof 运算符用来判断用于判断左侧参数是否属于右侧的实例
   obj instanceof Object 检测 Object.prototype 是否存在于参数 obj 的原型链上。
2. typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型。如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof

```
([1,2.3]) instanceof Array // true
({}) instanceof Object // true
(new Date) instanceof Date // true
(function(){}) instanceof Function // true
```

### this

this 是对应执行环境。this 是在调用时被绑定的，取决于函数的调用方法。
默认绑定、隐式绑定、显示绑定、new 绑定。优先级从低到高。

1. 默认绑定：最常用也是函数调用类型，当只有一个独立函数时，this 指向的是 window 对象
2. 隐式绑定: 函数调用的位置有上下文环境（对象调用模式，函数是一个对象的方法）
3. 显示绑定: 通过 apply，call，bind，直接将函数中的 this 绑定到想要的对象上
4. 构造函数模式: 创建一个构造函数的实例，构造函数中的 this 会绑定到这个实例对象上

### es6 新特性

#### let 和 const var

var：有变量提升，可重复生命，var 在全局作用域下声明变量会导致变量挂载在 window 上
let 和 const：没有变量提升，不能重复声明

#### 箭头函数的 this

1. 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。
2. 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。
3. 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替

#### promise

Promise 是一个对象，有 then()方法的对象,Promise 是异步编程的一种解决方案。有三种状态
　　等待中（pending）
　　完成了 （resolved）
　　拒绝了（rejected）
这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变

优点：Promise 的写法是回调函数的改进，使用 then 方法以后，异步任务的两段执行看得更清楚了。then 将原来异步函数的嵌套关系转变为链式步骤,很好地解决了回调地狱的问题
缺点：Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。

#### async await

一个函数如果加上 async ，那么该函数就会返回一个 Promise 对象

- await 等待右侧表达式的结果，这个结果是 promise 对象或者其他值。
- 如果它等到的不是一个 promise 对象，那 await 表达式的运算结果就是它等到的东西。
- 如果它等到的是一个 promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。

优点：代码简洁、几乎和同步代码一样，可读性好
缺点：滥用 await 可能会导致性能问题，因为 await 会阻塞代码

#### 字符串模板

let time = `now time is ${new Date}`

#### new Set 数组去重

[...new Set([1,2,3,4,2,3,3])]//[1,2,3,4]

#### symbol

##### 简介

ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值，这样就从根本上防止属性名的冲突。
Symbol 值通过 Symbol 函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。

```
// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();
s1 === s2 // false

// 有参数的情况
let s1 = Symbol('foo');
let s2 = Symbol('foo');
s1 === s2 // false
```

上面代码中，s1 和 s2 都是 Symbol 函数的返回值，而且参数相同，但是它们是不相等的。

##### 作为属性名

Symbol 作为属性名，遍历对象的时候，该属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。
由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。

#### Proxy

Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。
var proxy = new Proxy(target, handler);
Proxy 对象的所有用法，都是上面这种形式，不同的只是 handler 参数的写法。其中，new Proxy()表示生成一个 Proxy 实例，target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。

```
var proxy = new Proxy({}, {
  get: function(target, propKey) {
    return 35;
  }
});

proxy.time // 35
proxy.name // 35
proxy.title // 35
```

#### 迭代器

Iterator 是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。

1. ES6 引入了一种新的遍历命令 for...of 循环，Iterator 接口主要提供 for...of 使用
2. 原生具备 Iterator 接口的数据
   Array、Arguments、Set、Map、String、TypedArray、NodeList
3. 工作原理

- 创建一个指针对象，指向当前数据结构的起点位置
- 第一次调用对象的 next 方法，指针自动指向数据结构的第一元素
- 接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个元素
- 每调用 next 方法返回一个包含 value 和 done 属性的对象

```
// 自定义遍历数据
const obj = {
  name: "终极一班",
  stus: ['xiaoming', 'xiaoning', 'xiaotian'],
  [Symbol.iterator]() {
      let index = 0;
      let self = this;
      return {
          next: function () {
              if (index < self.stus.length) {
                  const result = { value: self.stus[index], done: false };
                  index++;
                  return result;
              }
              return {value: undefined, done: true};
          }
      };
  }
}
```

#### 生成器

生成器函数是 ES6 提供的一种异步编程解决方案，语法和行为与传统函数完全不同

```
function * gen() {
  yield '1';
  yield '2';
  return '3';
}
const iterator = gen();
console.log(iterator.next()); // { value: "1", done: false }
console.log(iterator.next()); // { value: "2", done: false }
console.log(iterator.next()); // { value: "3", done: true }
```

代码说明：

1. 生成器函数需要加 \*
2. 生成器函数返回的结果是迭代器对象，调用迭代器对象的 next 方法可以得到 yield 语句后面的值
3. yield 相当于函数的暂停标记，也可以认为是函数的分隔符，每次调用一次 next 方法，执行一段代码
4. next 方法可以传递实参，作为 yield 语句的返回值

#### Set

Set 是一个集合，类似于数组，但成员的值都是唯一的，集合实现了 Iterator 接口，所以可以使用扩字运算符和 for...of 进行遍历。
Set 主要的方法：

1. size 返回集合的个数
2. add 增加一个新元素，返回当前集合
3. delete 删除元素，返回 boolean 值
4. has 检测集合中是否包含某个元素，返回 boolean 值
5. clear 清空集合，返回 undefined

应用场景：

```
const arr = [1,2,3,4,5,4,3,2,1];
const arr2 = [4,5,6,5,6];
const newArr2 = new Set(arr2);

//1. 数组去重
const result = [...new Set(arr)];

//2. 交集
const result = [...new Set(arr)].filter(item => newArr2.has(item));

//4. 差集
let diff = [...new Set(arr)].filter(item => !(newArr2.has(item)));

//3. 并集
// let union = [...new Set([...arr, ...arr2])];
```

#### Map

Map 类似于对象，也是键值对的集合。但是“健”的范围不限于字符串，各种类型的值（包括对象）都可以当做健。Map 也实现了 iterator 接口，所以可以使用扩字运算符和 for...of 进行遍历。
Map 的主要方法：

1. size 返回 Map 的元素个数
2. set 增加一个新元素，返回当前 Map
3. get 返回键名对象的健值
4. has 检测 Map 中是否包含某个元素，返回 boolean 值
5. clear 清空集合，返回 undefined

#### class

ES6 的 class 可以看作只是一个语法糖，它的大部分功能 ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象的语法。
class 的主要属性和方法：

1. class 声明类
2. constructor 定义构造函数初始化
3. extends 继承父类
4. super 调用父级构造方法
5. static 定义静态方法和属性
6. 父类方法可以重写

#### Reflect

Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect 对象的设计目的有这样几个。

1. 从 Reflect 对象上可以拿到语言内部的方法。
2. 修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false。
3. 让 Object 操作都变成函数行为。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name)和 Reflect.deleteProperty(obj, name)让它们变成了函数行为。
4. Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。

```
var loggedObj = new Proxy(obj, {
  get(target, name) {
    console.log('get', target, name);
    return Reflect.get(target, name);
  },
  deleteProperty(target, name) {
    console.log('delete' + name);
    return Reflect.deleteProperty(target, name);
  },
  has(target, name) {
    console.log('has' + name);
    return Reflect.has(target, name);
  }
});
```

上面代码中，每一个 Proxy 对象的拦截操作（get、delete、has），内部都调用对应的 Reflect 方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。

#### includes

是否包含，用于字符串和数组

参数
includes(search[, fromIndex])
search: 需要查找的元素值
fromIndex[可选]: 从 fromIndex 索引处开始查找，默认为 0。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜

```
'abcd'.includes('cd'); // true
['a', 'b', 'c', 'd'].includes('c'); // true
```

#### 幂运算

```
console.log(2 ** 10); // 1024 相当于 Math.pow(2, 10)
```

#### Object.getOwnPropertyDescriptors(obj)

获取对象属性的描述

```
const a = {a: 1}
Object.getOwnPropertyDescriptors(a)
将获取到下面的结果
{
  "a": {
    "value": 1,
    "writable": true,
    "enumerable": true,
    "configurable": true
  }
}
```

#### 正则扩展-命名捕获分组

命名捕获组使用符号[?<name>]，这样获取的结果可读性更强

```
const str = '<a href="http://www.baidu.com">百度</a>';
//分组命名
const reg = /<a href="(?<url>.*)">(?<text>.*)<\/a>/;
const result = reg.exec(str);

console.log(result.groups.url); // http://www.baidu.com
console.log(result.groups.text); // 百度
```

#### 正则扩展-反向断言

```
const str = 'ES2018反向断言666';
//正向断言
// const reg = /\d+(?=反向断言)/;
// console.log(reg.exec(str)[0]); // 2018

//反向断言
const reg = /(?<=反向断言)\d+/;
console.log(reg.exec(str)[0]); // 666
```

#### 正则扩展-dotAll 模式

dotAll 属性表明是否在正则表达式中一起使用"s"修饰符（引入/s 修饰符，使得.可以匹配任意单个字符）。

```
/hello.world/.test('hello\nworld');  // false
/hello.world/s.test('hello\nworld'); // true
```

#### Object.fromEntries()

Object.fromEntries() 是 Object.entries() 的反转

```
const arr = [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ];
const obj = Object.fromEntries(arr); // { 0: "a", 1: "b", 2: "c" }
```

#### trimStart 与 trimEnd

去掉字符串前面或者后面的空格

#### Symbol.prototype.description

Symbol.prototype.description 可以获取 symbol 的描述

```
var a = Symbol('test')
a.description // test
```

#### flat() 和 flatMap()

##### flat

flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。

var newArray = arr.flat([depth])
depth 可选，指定要提取嵌套数组的结构深度，默认值为 1。

```
var arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2); // [1, 2, 3, 4, 5, 6]
```

##### flatMap

flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 连着深度值为 1 的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。

```
var arr1 = [1, 2, 3, 4];
arr1.flatMap(x => [x * 2]); // [2, 4, 6, 8]
```

#### 私有属性

```
class Person{
    name; // 公有属性
    #age; // 私有属性
}
```

#### Promise.allSettled

该 Promise.allSettled()方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。
当有多个彼此不依赖的异步任务成功完成时，或者您总是想知道每个 promise 的结果时，通常使用它。

```
const promise1 = Promise.resolve(3);
const promise2 = new Promise((resolve, reject) => setTimeout(reject, 1000, 'foo'));
const promises = [promise1, promise2];

Promise.allSettled(promises).then((results) => results.forEach((result) => console.log(result.status)));
// 输出 fulfilled 和 rejected
```

#### String.prototype.matchAl

matchAll() 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器。使用 matchAll ，就可以使用 while 循环加 exec 方式。使用 matchAll 会得到一个迭代器的返回值，配合 for...of 可以更方便实现功能

```
const str = 'table football, foosball';
const reg = /foo*/g
let matches = str.matchAll(reg);
for (const match of matches) {
  console.log(match); // Array [ "foo" ]
}
```

#### 可选链操作符

```
const dbHost = config?.db?.host;
等于下面语句
const dbHost = config && config.db && config.db.host;
```

#### 动态 import

动态引用文件，可实现按需加载

```
// hello.js
export function hello(){
    alert('Hello');
}
// 使用
const btn = document.getElementById('btn');
btn.onclick = function(){
  import('./hello.js').then(module => {
    module.hello();
  });
}

```

#### BigInt

JavaScript 中 Number 类型只能安全的表示-(2^53-1)至 2^53-1 范的值，即 Number.MIN_SAFE_INTEGER 至 Number.MAX_SAFE_INTEGER，超出这个范围的整数计算或者表示会丢失精度。BigInt 可以解决这个问题，BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数。
Bigint 有两种方式

1. 在整数字面量后面加 n。
   var bigIntNum = 9007199254740993n;
2. 使用 BigInt 函数。
   var bigIntNum = BigInt(9007199254740);

#### globalThis

globalThis 目的是提供一种标准化方式访问全局对象，有了 globalThis 后，你可以在任意上下文，任意时刻都能获取到全局对象。

### 事件传播机制

- window 往事件触发处传播，遇到注册的捕获事件会触发
- 传播到事件触发处时触发注册的事件
- 从事件触发处往 window 传播，遇到注册的冒泡事件会触发

事件代理：

- 因为冒泡机制，比如既然点击子元素，也会触发父元素的点击事件，那我们完全可以将子元素的事件要做的事写到父元素的事件里，也就是将子元素的事件处理程序写到父元素的事件处理程序中，这就是事件委托。
- 每当将事件处理程序制定给元素时，运行中的浏览器代码与支持页面交互的 JS 代码之间就会建立一个连接，而这种连接越多，页面执行起来就越慢。考虑内存和性能问题，为了解决事件处理程序过多的问题，采用事件委托变得很有必要。

### 事件循环机制

补充下有关宏任务和微任务的知识

- 宏任务和微任务都是队列，宏任务有 script、setTimeout、setInterval 等，微任务有 Promise.then catch finally、process.nextTick 等，宏任务和微任务的关系如下：
- 先执行第一个宏任务，执行结束后，执行所有的微任务，然后执行下个宏任务。

执行顺序

1. 一开始整个脚本作为一个宏任务执行
2. 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
3. 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完
4. 执行浏览器 UI 线程的渲染工作
5. 检查是否有 Web Worker 任务，有则执行
6. 执行完本轮的宏任务，回到 2，依此循环，直到宏任务和微任务队列都为空

### js 垃圾回收机制

什么是垃圾
一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。

js 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存。
定期执行以下“垃圾回收”
　　 01.垃圾回收器获取根并“标记”(记住)它们。
　　 02.然后它访问并“标记”所有来自它们的引用。
　　 03.然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。
　　 04.以此类推，直到有未访问的引用(可以从根访问)为止。
　　 05.除标记的对象外，所有对象都被删除。

出处[出处](https://segmentfault.com/a/1190000018605776)

### call apply bind

改变 this 的指向
　　 call 第二个参数接受的是若干个参数列表
　　 apply 第二参数接收的是一个包含多个参数的数组
　　 bind 返回一个函数，需要手动去调用

### new 的原理

在调用 new 的过程中会发生以上四件事情：

1. 新生成了一个对象
2. 链接到原型
3. 绑定 this
4. 返回新对象

```
function create(Con, ...args) {
  let obj = {};
  Object.setPrototypeOf(obj, Con.prototype);
  let result = Con.apply(obj, args);
  return result instanceof Object ? result : obj;
}
```

### es5 和 es6 去重;

```
es5[(1, 1, 2, 1, 2)].filter((item, i, arr) => {
  return arr.indexOf(item) === i;
});
es6: [...new Set([1, 2, 3, 3, 2])];
```

### requestAnimationFrame

requestAnimationFrame 是浏览器用于定时循环操作的一个接口，类似于 setTimeout，主要用途是按帧对网页进行重绘。对于 JS 动画，用 requestAnimationFrame 会比 setInterval 效果更好。

### 取消冒泡和取消默认行为

取消冒泡

```
if(e.stopPropagation) {
  e.stopPropagation();
} else {
  // ie: e.cancelBubble=true;
  e.cancelBubble=true;
}
```

取消事件

```
if(e.preventDefault) {
  e.preventDefault();
} else {
  // ie: e.returnValue = false;
  e.returnValue = false;
}
```

### 前端安全

#### XSS

> 什么是 XSS 攻击？如何防范 XSS 攻击？

Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。
XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

主要有两种攻击方式

1. 反射型攻击--url 参数直接注入
   通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。
   举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行

```
<!-- http://www.domain.com?name=<script>alert(1)</script> -->
<div>{{name}}</div>
```

2. 注入型攻击--存储到 DB 后读取时注入
   攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。比如在输入框输入“<script>alert(1)</script>”后提交，这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。

防御方法：

1. 转义字符
   对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义

```
function escape(str) {
  str = str.replace(/&/g, '&amp;')
  str = str.replace(/</g, '&lt;')
  str = str.replace(/>/g, '&gt;')
  str = str.replace(/"/g, '&quto;')
  str = str.replace(/'/g, '&#39;')
  str = str.replace(/`/g, '&#96;')
  str = str.replace(/\//g, '&#x2F;')
  return str
}
```

通过转义可以将攻击代码 <script>alert(1)</script> 变成

```
escape('<script>alert(1)</script>')
// -> &lt;script&gt;alert(1)&lt;&#x2F;script&gt;
```

但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法。

```
const xss = require('xss')
let html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss");</script>')
// -> <h1>XSS Demo</h1>&lt;script&gt;alert("xss");&lt;/script&gt;
// 使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。
```

2. CSP
   CSP，全称 Content Security Policy，内容安全策略。CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。

通常可以通过两种方式来开启 CSP：

设置 HTTP Header 中的 Content-Security-Policy
设置 meta 标签的方式 <meta http-equiv="Content-Security-Policy">
这里以设置 HTTP Header 来举例

只允许加载本站资源
Content-Security-Policy: default-src ‘self’

只允许加载 HTTPS 协议图片
Content-Security-Policy: img-src https://*

允许加载任何来源框架
Content-Security-Policy: child-src 'none'

#### CSRF

> 什么是 CSRF 攻击？如何防范 CSRF 攻击？

CSRF 攻击，全称 Cross Site Request Forgy，跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。

如何防御

- 禁止第三方网站带 Cookies
  可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。

- 验证 Referer
  对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。

- Token
  服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。

#### 点击劫持

> 什么是点击劫持？如何防范点击劫持？

点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。

如何防御

1. X-FRAME-OPTIONS
   X-FRAME-OPTIONS 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。

该响应头有三个值可选，分别是
DENY，表示页面不允许通过 iframe 的方式展示
SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示
ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示

2. JS 防御
   通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。

#### 中间人攻击

> 什么是中间人攻击？如何防范中间人攻击？

中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。
通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。

如何防御
http 换成 https，并且完全关闭 http 访问

## 网络相关

#### 状态码

1XX 用于指定客户端相应的某些动作
　　 2XX 用于表示成功
　　 3XX 用于已经移动的文件并且被包含在定位头信息中指定心的地址信息(重定向，为了完成请求，必须进一步执行的动作)
　　 4XX 用于指出客户端错误
　　 5XX 用于支持服务器错误

100 继续；101 分组交换协议
　　 200 ok；201 被创建；202 被采纳；203 非授权信息；204 无内容；205 重置内容；206 部分内容；
　　 300 多选项；301 永久地传递；302 找到；303 参见其他；304 未改动；305 使用代理；307 暂时重定向；
　　 400 错误请求(可能是 get 请求写成 post 请求)；401 未授权；402 要求付费；403 禁止；405 不允许的方法；406 不被采纳；407 要求代码授权；408 请求超时；409 冲突；410 过期的；411 要求的长度；412 前提不成立；413 请求实例太大；414 请求 url 太大；415 不支持的媒体类型；416 无法满足的请求范围；417 失败的预期；
　　 500 内部服务器错误；501 未被使用；502 网关错误；503 不可用的服务；504 网关超时；505 HTTP 版本未被支持；

#### 解决跨域方法

当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。
同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。

1. jsonp
   　　利用<script>元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以。
   　　 JSONP 优点是兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持 get 方法具有局限性。
2. CORS
   　　 CORS 要求浏览器和服务器的同时支持，是跨域的根本解决方法，由浏览器自动完成。
   　　优点在于功能更加强大支持各种 HTTP Method，缺点是兼容性不如 JSONP。
3. websocket
   　　 WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。
4. postMessage
   　如果两个网页不同源，就无法拿到对方的 DOM。HTML5 为了解决这个问题，引入了一个全新的 API：跨文档通信 API（Cross-document messaging）。这个 API 为 window 对象新增了一个 window.postMessage 方法，允许跨窗口通信，不论这两个窗口是否同源。postMessage 方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即"协议 + 域名 + 端口"。也可以设为\*，表示不限制域名，向所有窗口发送。
   出处：https://blog.csdn.net/liangjielaoshi/article/details/83786388

#### 三次握手四次挥手

三次握手：
　　首先 Client 端发送连接请求报文，Server 段接受连接后回复 ACK 报文，并为这次连接分配资源。Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并分配资源，这样 TCP 连接就建立了。
四次挥手：
　　由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

#### 请求方式有哪些 Post 和 Get 的区别

请求方式
　　 01. GET 方法：发送一个请求来取得服务器上的某一资源
　　 02. POST 方法：向 URL 指定的资源提交数据或附加新的数据
　　 03. PUT 方法：跟 POST 方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT 指定了资源在服务器上的位置，而 POST 没有
　　 04. HEAD 方法：只请求页面的首部
　　 05. DELETE 方法：删除服务器上的某资源
　　 06. OPTIONS 方法：它用于获取当前 URL 所支持的方法。如果请求成功，会有一个 Allow 的头包含类似“GET,POST”这样的信息
　　 07. TRACE 方法：TRACE 方法被用于激发一个远程的，应用层的请求消息回路
　　 08. CONNECT 方法：把请求连接转换到透明的 TCP/IP 通道

get 和 post 的区别

1. GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。
   　　对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；
   　　而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。
2. get 请求数据有限制，post 请求数据没有限制
3. 请求参数在 url 中发送，post 请求参数在 http 消息主体中发送

#### http 和 https 的区别

有以下几点：
　　 01. Http 协议运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份；Https 是身披 SSL(Secure Socket Layer)外壳的 Http，运行于 SSL 上，SSL 运行于 TCP 之上，是添加了加密和认证机制的 HTTP。二者之间存在如下不同：
　　 02. 端口不同：Http 与 Http 使用不同的连接方式，用的端口也不一样，前者是 80，后者是 443；
　　 03. 资源消耗：和 HTTP 通信相比，Https 通信会由于加减密处理消耗更多的 CPU 和内存资源；
　　 04. 开销：Https 通信需要证书，而证书一般需要向认证机构购买；
　　 05. Https 的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。

#### http1.0 和 http1.1 的区别

1. http 1.0 对于每个连接都得建立一次连接, 一次只能传送一个请求和响应, 请求就会关闭, http1.0 没有 Host 字段，而 http1.1 在同一个连接中可以传送多个请求和响应, 多个请求可以重叠和同时进行, http1.1 必须有 host 字段
2. http1.1 中引入了 ETag 头, 它的值 entity tag 可以用来唯一的描述一个资源. 请求消息中可以使用 If-None-Match 头域来匹配资源的 entitytag 是否有变化
3. http1.1 新增了 Cache-Control 头域(消息请求和响应请求都可以使用), 它支持一个可扩展的指令子集
4. http1.0 中只定义了 16 个状态响应码, 对错误或警告的提示不够具体. http1.1 引入了一个 Warning 头域, 增加对错误或警告信息的描述. 且新增了 24 个状态响应码

#### http 和 tcp 的区别

HTTP 的责任是去定义数据，在两台计算机相互传递信息时，HTTP 规定了每段数据以什么形式表达才是能够被另外一台计算机理解。
而 TCP 所要规定的是数据应该怎么传输才能稳定且高效的传递与计算机之间。

#### tcp 和 udp 的区别

#### 请求过程

折中后的五层协议
　　 01 应用层(dns,http) DNS 解析成 IP 并发送 http 请求
　　 02 传输层(tcp,udp) 建立 tcp 连接（三次握手）
　　 03 网络层(IP,ARP) IP 寻址
　　 04 数据链路层(PPP) 封装成帧
　　 05 物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）

简括：从应用层的发送 http 请求，到传输层通过三次握手建立 tcp/ip 连接，再到网络层的 ip 寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。

## 浏览器相关

### 介绍一下你对浏览器引擎的理解，常见的浏览器内核有哪些

> 主要分成两个部分：渲染引擎和 JS 引擎。

1. 渲染引擎：负责取得网页的内容(html,xml 和图像等)，整理讯息(例如假如 css)，以及计算网页的显示方式，然后输出到显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同。
2. JS 引擎：解析和执行 JavaScript 来实现网页的动态效果。

> 常见的浏览器内核：

- Trident：IE，360，搜过浏览器；
- Gecko：Firefox
- Blink：Opera；
- Webkit：Safari，Chrome
- Presto：Opera

### 页面解析过程

如下几点  
　　 01.解析 html 文件，创建 DOM 树
　　　　自上而下解析，遇到任何样式（link、style）和脚本（script）都会阻塞
　　　　 001 css 加载不会阻塞 html 文件的解析，但会阻塞 dom 的渲染
　　　　 002 css 加载会阻塞后面 js 语句的执行
　　　　 003 js 会阻塞 html 的解析和渲染
　　　　 004 没有 defer 和 async 标签的 script 会立即加载并执行
　　　　 005 有 async 标签的 js，js 的加载执行和 html 的解析和渲染并行
　　　　 006 有 defer 标签的 js，js 的加载和 html 的解析和渲染并行，但会在 html 解析完成后执行,在触发 DOMContentLoaded 事件前执行
　　　　 007 DOMContentLoaded 和 onload 的区别：DOMContentLoaded 在 html 解析完毕后执行，loload 在页面完全加载完成后执行（包括样式和图片）
　　 02.解析 css，生成 CSSOM，css 对象模型
　　 03.dom 和 css 合并，构建渲染树（Render Tree）
　　 04.布局（Layout）和绘制（Paint），重绘（repaint）和重排（reflow/回流）
　　　　 001 重绘：根据元素的新属性重新绘制，使元素呈现新的外观
　　　　 002 重排：当渲染树中的一部分因为元素的规模尺寸，布局，隐藏等改变而需要重新构建
　　　　 003 重排必定会引发重绘，但重绘不一定会引发重排

### 性能优化

常用的性能优化方法
　　 01.减少 HTTP 请求数量
　　　　 001 将多张图片合并成一张图片
　　　　 002 合并 css 和 js 文件
　　 02.压缩 js 和 css
　　 03.css 放顶部，js 放底部
　　 　　浏览器在加载 HTML 内容时，是将 HTML 内容从上至下依次解析，解析到 link 或者 script 标签就会加载 href 或者 src 对应链接内容，为了第一时间展示页面给用户，就需要将 CSS 提前加载，不要受 JS 加载影响。
　　 04.去除重复脚本
　　 05.减少 DOM 操作
　　 06.懒加载
　　 07.减少重排（Reflow）
　　　　 重排是 DOM 的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它结点的 visibility 属性，这也是 Reflow 低效的原因。如果 Reflow 的过于频繁，CPU 使用率就会急剧上升。
　　 08.图标使用 iconFont 替换

## webpack 相关

### 什么是 webpack

- webpack 是一个打包模块化 javascript 的工具，在 webpack 里一切文件皆模块，通过 loader 转换文件，通过 plugin 注入钩子，最后输出由多个模块组合成的文件，webpack 专注构建模块化项目。
- WebPack 可以看做是模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript 等），并将其打包为合适的格式以供浏览器使用。

### 优缺点

优点
　　 01 专注于处理模块化的项目，能做到开箱即用，一步到位
　　 02 可通过 plugin 扩展，完整好用又不失灵活
　　 03 使用场景不局限于 web 开发
　　 04 社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展
　　 05 良好的开发体验
缺点
　　只能用于采用模块化开发的项目

### 分别介绍什么是 loader?什么是 plugin

loader：模块转换器，用于将模块的原内容按照需要转成你想要的内容
plugin：在 webpack 构建流程中的特定时机注入扩展逻辑，来改变构建结果，是用来自定义 webpack 打包过程的方式

### 分别介绍 bundle，chunk，module 是什么

- bundle：是由 webpack 打包出来的文件，
- chunk：代码块，一个 chunk 由多个模块组合而成，用于代码的合并和分割。
- module：是开发中的单个模块，在 webpack 的世界，一切皆模块，一个模块对应一个文件，webpack 会从配置的 entry 中递归开始找出所有依赖的模块。

### 什么是模块热更新

模块热更新是 webpack 的一个功能，他可以使得代码修改过后不用刷新浏览器就可以更新

### 通过 webpack 处理长缓存

在 webpack 中可以在 output 纵输出的文件指定 chunkhash,并且分离经常更新的代码和框架代码。通过 NameModulesPlugin 或是 HashedModuleIdsPlugin 使再次打包文件名不变。

### webpack-dev-server 和 http 服务器如 nginx 有什么区别

webpack-dev-server 使用内存来存储 webpack 开发环境下的打包文件，并且可以使用模块热更新，他比传统的 http 服务对开发更加简单高效。

### 如何提高 webpack 的构建速度

如下几点
01 通过 externals 配置来提取常用库
02 利用 DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引用但是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。
03 使用 Happypack 实现多线程加速编译
要注意的第一点是，它对 file-loader 和 url-loader 支持不好，所以这两个 loader 就不需要换成 happypack 了，其他 loader 可以类似地换一下
04 使用 Tree-shaking 和 Scope Hoisting 来剔除多余代码
05 使用 fast-sass-loader 代替 sass-loader
06 babel-loader 开启缓存
\_ babel-loader 在执行的时候，可能会产生一些运行期间重复的公共文件，造成代码体积大冗余，同时也会减慢编译效率
\_ 可以加上 cacheDirectory 参数或使用 transform-runtime 插件试试
07 不需要打包编译的插件库换成全局"script"标签引入的方式
\_ 比如 jQuery 插件，react, react-dom 等，代码量是很多的，打包起来可能会很耗时
\_ 可以直接用标签引入，然后在 webpack 配置里使用 expose-loader 或 externals 或 ProvidePlugin 提供给模块内部使用相应的变量
08 优化构建时的搜索路径
在 webpack 打包时，会有各种各样的路径要去查询搜索，我们可以加上一些配置，让它搜索地更快
　比如说，方便改成绝对路径的模块路径就改一下，以纯模块名来引入的可以加上一些目录路径
　还可以善于用下 resolve alias 别名 这个字段来配置
　还有 exclude 等的配置，避免多余查找的文件，比如使用 babel 别忘了剔除不需要遍历的
出处：https://www.jianshu.com/p/bb1e76edc71e

## vue 相关

### 生命周期

- 在 beforeCreate 钩子函数调用的时候，是获取不到 props 或者 data 中的数据的，因为这些数据的初始化都在 initState 中。然后会执行 created 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。
- 接下来会先执行 beforeMount 钩子函数，开始创建 VDOM，最后执行 mounted 钩子，并将 VDOM 渲染为真实 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。
- 接下来是数据更新时会调用的钩子函数 beforeUpdate 和 updated，分别在数据更新前和更新后会调用。
- 另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。
- 最后就是销毁组件的钩子函数 beforeDestroy 和 destroyed。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。

### 组件通信

- 父子间：prod emit
- 祖父组件和孙组件：$attr和$listeners
- 其他组件：bus 或者 vuex

### watch 和 computed 和 method 的区别

1. methods 和 computed
   　　对于最终的结果，两种方式确实是相同的。不同的是 computed 是基于它们的依赖进行缓存的。computed 只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。相比而言，只要发生重新渲染，method 调用总会执行该函数。总之，重新计算开销很大的话请选 computed，不希望有缓存的请选 methods。
2. watch 和 computed

- 当你在模板内使用了复杂逻辑的表达式时，你应当使用 computed。
- watch 是一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。
- 当你有一些数据需要随着其它数据变动而变动时，或者当需要在数据变化时执行异步或开销较大的操作时，你可以使用 watch

### mixins

mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码。mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并

### keep-alive 组件有什么作用

如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。

### 响应式原理

- vue 将 data 初始化为一个 Observer 并对对象中的每个值，重写了其中的 get、set，data 中的每个 key，都有一个独立的依赖收集器。
- 在 get 中，向依赖收集器添加了监听
- 在 mount 时，实例了一个 Watcher，将收集器的目标指向了当前 Watcher
- 在 data 值发生变更时，触发 set，触发了依赖收集器中的所有监听的更新，来触发 Watcher.update

### NextTick

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

### vue-router 原理 传参 模式

- 原理：本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。
- 传参：query、params、prods、直接跟在 URL 后面
- 模式：Hash 和 history
  　　　　　　 Hash 模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL
  　　　　　　 History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串
  　　　　　　 Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候

### vuex

state getters mutations（应用于同步，commit 触发） actions（应用于异步，dispatch 触发）

### 对 MVVM 的理解

- Vue 是以数据为驱动的，Vue 自身将 DOM 和数据进行绑定，一旦创建绑定，DOM 和数据将保持同步，每当数据发生变化，DOM 会跟着变化。
- ViewModel 是 Vue 的核心，它是 Vue 的一个实例。Vue 实例是作用在某个 HTML 元素上的，这个 HTML 元素可以是 body，也可以是某个 id 所指代的元素。
  DOM Listeners 和 DataBindings 是实现双向绑定的关键。DOM Listeners 监听页面所有 View 层 DOM 元素的变化，当发生变化，Model 层的数据随之变化；DataBindings 监听 Model 层的数据，当数据发生变化，View 层的 DOM 元素随之变化。

### vue 虚拟 dom 原理

Virual DOM 是用 JS 对象记录一个 dom 节点的副本，当 dom 发生更改时候，先用虚拟 dom 进行 diff，算出最小差异，然后再修改真实 dom。
　　　　优点：
　　　　　　 01 将 Virtual DOM 作为一个兼容层，让我们还能对接非 Web 端的系统，实现跨端开发。
　　　　　　 02 同样的，通过 Virtual DOM 我们可以渲染到其他的平台，比如实现 SSR、同构渲染等等。
　　　　　　 03 实现组件的高度抽象化
　　　　缺点：
　　　　　　 01. 代码更多，体积更大
　　　　　　 02. 内存占用增大
　　　　　　 03. 小量的单一的 dom 修改使用虚拟 dom 成本反而更高，不如直接修改真实 dom 快

### vue2 和 vue3 对比

vue2
Vue2 响应式是通过 Object.defineProperty 实现的。getter 用来依赖收集，setter 在数据变化时通知订阅者更新视图。
这种方式存在一些缺陷：

1. 无法检测到对象属性的新增或者删除。 Object.defineProperty 只会是属性的读写才会触发，所以新增、删除都无法检测。Vue 为了做到新增、删除也是响应式，做了一些手段 Vue.set(obj, propertName/index, value)、响应式对象的子对象新增属性，可以给子响应式对象重新赋值。
2. 不能监听数组的变化 Vue 在数组做了 hack，把无法监听的情况下，通过重写数组 push/pop/shift/unshift/splice/sort/reverse 7 个方法实现响应式。

vue3
在 vue3 中，Object.defineProperty 用 Proxy 改写了。

Object.defineProperty
Vue2 中，对于给定的 data：如 { count: 1 }，是需要根据具体的 key 也就是 count，去对 get 和 set 进行拦截，也就是：

```
Object.defineProperty(data, 'count', {
  get() {},
  set() {},
})
```

必须预先知道要拦截的 key 是什么，这也就是为什么 Vue2 里对于对象上的新增属性无能为力，所以 Vue 初始化的过程中需要遍历 data 来挟持数据变化。

Proxy
而 Vue3 所使用的 Proxy，则是这样拦截的：

```
new Proxy(data, {
  get(key) { },
  set(key, value) { },
})
```

可以看到，proxy 不需要关心具体的 key，它去拦截的是修改 data 上的任意 key 和读取 data 上的任意 key
所以，不管是已有的 key 还是新增的 key，都会监听到

总结优点：

1. 对对象已有或新增的属性都能进行监听
2. 对数组或函数进行监听

Proxy 的缺点：
Proxy 兼容性不如 Object.defineProperty

### vue react angular 的区别

vue:
　　　　　　优点：
　　　　　　　　 a.简单，容易上手
　　　　　　　　 b.轻量级的框架，且没有依赖
　　　　　　　　 c.能快速的更新 dom
　　　　　　　　 d.对模块友好，可以通过 npm、bower 安装
　　　　　　　　 e.可复用的组件
　　　　　　　　 f.双向数据绑定
　　　　　　缺点：
　　　　　　　　 a.没有 angular 那么成熟
　　　　　　　　 b.不支持 IE8 以下

angular：
　　　　　　优点：
　　　　　　　　 a.双向数据绑定
　　　　　　　　 b.模版动能强大，指令丰富
　　　　　　　　 c.可以复用的自定义指令
　　　　　　　　 d.比较完善，包含模版、模块化、路由、过滤器、依赖注入等
　　　　　　　　 e.组件化
　　　　　　缺点：
　　　　　　 a.过于臃肿
　　　　　　 b.什么都要依赖注入

react：
　　　　　　优点：
　　　　　　　　 a.速度快，通过虚拟 DOM 更新实际 DOM
　　　　　　　　 b.浏览器兼容性好
　　　　　　　　 c.组件化
　　　　　　　　 d.对 SEO 友好
　　　　　　　　 e.单向响应数据流
　　　　　　缺点：
　　　　　　　　 a.只是个视图，并不完整，如果是大型项目需要配合其它框架，如 react-router 和 readux

## angular 相关

## react 相关

## node 相关

## 其他
