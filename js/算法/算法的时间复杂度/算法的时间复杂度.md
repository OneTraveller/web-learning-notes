# 算法的复杂度

一个算法的优劣可以用空间复杂度和时间复杂度来衡量。一个不用准确的测试结果来衡量，就可以粗略地估计代码执行时间的方法。这就是复杂度分析。

## 时间复杂度

表示程序执行的快慢，评估执行程序所需的时间。一般情况下，没有特殊说明，复杂度就是指时间复杂度。

## 空间复杂度

表示内存的消耗，评估执行程序所需的存储空间。

## 大 O 表示法

算法的时间复杂度通常用大 O 符号表述。

推导大 O 阶，我们可以按照如下的规则来进行推导，得到的结果就是大 O 表示法：

1. 用常数 1 来取代运行时间中所有加法常数。
2. 修改后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且不是 1，则去除与这个项相乘的常数。

估算代码的执行时间

```
function total(n) { // 1
  var sum = 0; // 2
  for (var i = 0; i < n; i++) { // 3
    sum += i; // 4
  } //5
} //6
```

我们假设每行代码执行的时间都一样，记做 t，那么上面的函数中的第 2 行需要 1 个 t 的时间，第 3 行 和 第 4 行分别需要 n 个 t 的时间，那么这段代码总的执行时间为 (2n+1)\*t。

```
 function total(n) { // 1
  var sum = 0; // 2
  for (var i = 0; i < n; i++) { // 3
    for (var j = 0; j < n; j++) { // 4
      sum = sum + i + j; // 5
    }
  }
}
```

第 2 行需要一个 t 的时间，第 3 行需要 n 个 t 的时间，第 4 行和第 5 行分别需要 n2 个的时间，那么这段代码总的执行时间为 (2n2+n+1)\*t 的时间。

从数学角度来看，我们可以得出个规律：代码的总执行时间 T(n) 与每行代码的执行次数成正比

```
T(n) = O(f(n))
```

在这个公式中，T(n) 表示代码的执行时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和；O 表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

所以上边两个函数的执行时间可以标记为 T(n) = O(2n+1) 和 T(n) = O(2n2+n+1)。这就是大 O 时间复杂度表示法，它不代表代码真正的执行时间，而是表示代码随数据规模增长的变化趋势，简称时间复杂度。
而且当 n 很大时，我们可以忽略常数项，只保留一个最大量级即可。所以上边的代码执行时间可以简单标记为 T(n) = O(n) 和 T(n) = O(n2)。

### O(1)

```
function total() {
  var sum = 0;
  for(var i=0;i<100;i++) {
    sum += i;
  }
}
```

虽然有这么多行，即使 for 循环执行了 100 次，但是代码的执行时间不随 n 的增大而增长，所以这样的代码复杂度就为 O(1)。

### O(n)

```
function total(n) { // 1
  var sum = 0; // 2
  for (var i = 0; i < n; i++) { // 3
    sum += i; // 4
  } //5
} //6
```

只有第 3 行和第 4 行是执行次数最多的，分别执行了 n 次，那么忽略常数项，所以此段代码的时间复杂度就是 O(n)。

### O(logn)

```
function total(n) {
  var sum = 0;
  for (var i = 1; i <= n; i = i * 2) {
    sum += i;
  }
}
```

上面两个函数都有一个相同点，变量 i 从 1 开始取值，每循环一次乘以 2，当大于 n 时，循环结束。实际上，i 的取值就是一个等比数列，就像下面这样

> 20 21 22 ... 2k... 2x =n;

所以只要知道 x 的值，就可以知道这两个函数的执行次数了。那由 2x = n 可以得出 x = log2n，所以这两个函数的时间复杂度为 O(log2n)。

```
function total2(n) {
  var sum = 0;
  for (var i = 1; i <= n; i = i * 3) {
    sum += i;
  }
}
```

由上可以得知，这两个函数的时间复杂度为 O(log3n) 。

由于我们可以忽略常数，也可以忽略对数中的底数，所以在对数阶复杂度中，统一表示为 O(logn)

### O(nlogn)

```
function total(n) {
  var sum = 0;
  for (var i = 1; i <= n; i++) {
    for (var j = 1; j <= n; j = j * 2) {
      sum += j;
    }
  }
}
```

O(nlogn) 的含义就很明确，时间复杂度 为 O(logn) 的代码执行了 n 次。

### O(m+n)

```
 function total(m,n) {
  var sum1 = 0;
  for (var i = 0; i < n; i++) {
    sum1 += i;
  }
  var sum2 = 0;
  for (var i = 0; i < m; i++) {
    sum2 += i;
  }
  return sum1 + sum2;
}
```

因为我们无法评估 m 和 n 谁的量级比较大，所以就不能忽略掉其中一个，这个函数的复杂度是有两个数据的量级来决定的，所以此函数的时间复杂度为 O(m+n)；那么 O(m\*n) 的时间复杂度类似。

### O(n2)

```
var sum = 0;
for(let i=0; i<n; i++){
    for(let j=i; j<n; j++){
        sum += 1;
    }
}
```

循环的时间复杂度为 O(n2)。

### 其他常见复杂度

除了常数阶、线性阶、平方阶、对数阶，还有如下时间复杂度：
f(n)=n³ 时，时间复杂度为 O(n³)，可以称为立方阶。
f(n)=2ⁿ 时，时间复杂度为 O(2ⁿ)，可以称为指数阶。
f(n)=n!时，时间复杂度为 O(n!)，可以称为阶乘阶。
f(n)=(√n 时，时间复杂度为 O(√n)，可以称为平方根阶。

## 比较

![时间对比](./img/bigO.png)

> O(1)<O(logn)<O(n)<O(nlogn)<O(n²)<O(n³)<O(2ⁿ)<O(n!)
> 复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，一个表示执行的快慢，一个表示内存的消耗，用来分析算法执行效率与数据规模之间的增长关系，可以粗略的表示，越高阶复杂度的算法，执行效率越低。

## 参考链接

[https://juejin.im/post/6844903750985842695](https://juejin.im/post/6844903750985842695)
[https://juejin.im/post/6844903757143080973](https://juejin.im/post/6844903757143080973)
[https://juejin.im/post/6844903470881849352](https://juejin.im/post/6844903470881849352)
