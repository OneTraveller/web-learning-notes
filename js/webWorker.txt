webWorker

1.简介
  web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。
  所有主流浏览器均支持 web worker，除了 Internet Explorer。

2.基本用法
  ● 主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程
      const worker = new Worker('work.js');
    Worker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。
  ● 主线程调用worker.postMessage()方法，向 Worker 发消息。
      worker.postMessage('Hello World');
      worker.postMessage({method: 'echo', args: ['Work']});
    worker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。 
  ● 主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。
      worker.onmessage = function (event) {
        console.log('Received message ' + event.data);
        doSomething();
      }
  ● Worker 完成任务以后，主线程就可以把它关掉。
      worker.terminate();

3.常用API
  ● 主线程
    ● Worker.onerror：指定 error 事件的监听函数。
    ● Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。
    ● Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。
    ● Worker.postMessage()：向 Worker 线程发送消息。
    ● Worker.terminate()：立即终止 Worker 线程。
  ● Worker 线程
    ● self.name： Worker 的名字。该属性只读，由构造函数指定。
    ● self.onmessage：指定message事件的监听函数。
    ● self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。
    ● self.close()：关闭 Worker 线程。
    ● self.postMessage()：向产生这个 Worker 线程发送消息。
    ● self.importScripts()：加载 JS 脚本。

4.webWorker 有以下几个使用注意点
  （1）同源限制
    分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。

  （2）DOM 限制
    Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。

  （3）通信联系
    Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。

  （4）脚本限制
    Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。

  （5）文件限制
    Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。
    

demo链接：https://github.com/OneTraveller/demo/tree/master/webWorker

参考：http://www.ruanyifeng.com/blog/2018/07/web-worker.html

