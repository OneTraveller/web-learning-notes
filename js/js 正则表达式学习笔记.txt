正则表达式
正则表达式是由一个字符序列形成的搜索模型

1.语法
  new RegExp("[abc]")
  /[abc]/
  /正则表达式主体/修饰符(可选)

  1.修饰符
  i 忽略大小写
  g 执行全局匹配 //global
  m 执行多行匹配

2.表达式
  [abc] 查找方括号之间的任何字符
  [^abc] 查找任何不在方括号之间的字符
  [0-9] 查找任何从0至9的数字
  [a-z]查找任何从小写a到小写z的字符
  (x|y) 查找任何|分割的选项

3.元字符
  . 查找任意的单个字符，除了换行符外
  \d 查找数字 === [0-9] digit(数字)
  \D查找非数字 === [^0-9] 
  \s 查找空白字符 space
  \b 匹配一个单词边界，也就是指单词和空格间的位置，比如’er\b’可以匹配”never”中的”er”,但是不能匹配”verb”中的”er”
  \w 查找任意一个字母或数字或下划线，等价于[a-zA-Z0-9_] word
  \uxxxx 查找以十六进制xxxx规定的Unicode字符
  匹配任何字符 [\d\D]或[\w\W]或[\s\S]或[^]

4.量词
  n+ 匹配任何包含至少一个n的字符 === n{1,}
  n* 匹配任何包含零个或多个n的字符串 === n{0,}
  n? 匹配任何含零或一个n的字符串 === n{0,1 }
  ?=n 匹配任何其后紧接指定字符串n的字符串，不包含n， 就是n前面的那个位置
  ?:n 匹配任何其后紧接指定字符串n的字符串，包含n
  ?!n 匹配任何其后没有紧接指定字符串n的字符串
  (?<!exp)"匹配前面不是exp的位置；如：/(?!<\d)123/.exec("abc123 ") //["123", index: 3, input: "abc123 "]
  ^n 匹配任何开头为n的字符串
  n$ 匹配任何结尾为n的字符串
  /\d{2,5}?/ 表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不再往下尝试了
  (?!^)表示不是开头位置

5. 方法
1)String对的方法
  str.search(/表达式/) 返回匹配到的第一个位置
  str.split(/表达式/)
  str.match(/表达式/)
  str.replace(/表达式/,'')
2)RegExp对象方法
  /表达式/.test(str) 返回布尔值
  /表达式/.exec(str) 返回一个数组，存放匹配的结果，如果未找到匹配，则返回值为null

6.$
  1、 2、...、$99	与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。
  $&	与 regexp 相匹配的子串
  $`	位于匹配子串左侧的文本
  $'	位于匹配子串右侧的文本
  $$	直接量符号

  //第一种情况：
  'aa11AA'.replace(/([a-z]+)(\d+)([A-Z]+)/g, '$1'); // "aa"
  'aa11AA'.replace(/([a-z]+)(\d+)([A-Z]+)/g, '$2'); // "11"
  'aa11AA'.replace(/([a-z]+)(\d+)([A-Z]+)/g, '$3'); // "AA"
  //猜想 如果是 $4 回事什么呢？ undefined ? 
  'aa11AA'.replace(/([a-z]+)(\d+)([A-Z]+)/g, '$4'); // "$4"
  //所以，要是没有该子项，则当成普通字符串处理了
  //第二种情况：
  'aa11AA'.replace(/([a-z]+)(\d+)([A-Z]+)/g, '$&'); //"aa11AA"
  //第三种情况：
  'aa11AA'.replace(/(\d+)/g, '$`'); //"aaaaAA"
  //第四种情况：
  'aa11AA'.replace(/(\d+)/g, "$'"); //"aaAAAA"
  //第五种情况：
  'aa11AA'.replace(/(\d+)/g, '$$'); //"aa$AA"

7.懒惰限定符(贪婪模式加？变为非贪婪模式)
  "*?" 重复任意次，但尽可能少重复；如:"aabab".match(/a.*?b/)
  // ["aab"] 为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？
  简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权。
  "+?" 重复1次或更多次，但尽可能少重复，与上面一样，只是至少要重复1次。如："aabab".match(/a.+?b/)
  // ["aab"]"??" 重复0次或1次，但尽可能少重复。如："aabab".match(/a.??b/)
  // ["aab"]
  "{n,m}?" 重复n到m次，但尽可能少重复。如："aaa".match(/a{1,3}?/)
  // ["a"]
  "{n,}?" 重复n次以上，但尽可能少重复。如："aaa".match(/a{1,}?/)
  // ["a"]


8.需要转义的字符
  * . ? + $ ^ [ ] ( ) { } | \ /

9. 临时缓存区
  正则表达式一个最重要的特性就是将匹配成功的模式的某部分进行存储供以后使用这一能力。
  对一个正则表达式模式或部分模式两边添加圆括号将导致这部分表达式存储到一个临时缓冲区中。
  （可以使用非捕获元字符 '?:', '?=', 或 '?!' 来忽略对这部分正则表达式的保存。）
  所捕获的每个子匹配都按照在正则表达式模式中从左至右所遇到的内容存储。
  存储子匹配的缓冲区编号从 1 开始，连续编号直至最大 99 个子表达式。
  每个缓冲区都可以使用 '\n' 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。
  /^(\d{1,4})(-|\/)(\d{1,2})\2(\d{1,2})$/
  判断是否为yyyy-mm-dd格式的类型
  \2 这里是匹配 (-|\/) 这里的字符，也就是，如果前面用了 - ，那这里也匹配 -，如果前面是 / ，那这里也匹配 /
  /^(\d{1,4})(-|\/)(\d{1,2})\2(\d{1,2})$/ === /^(\d{1,4})(-|\/)(\d{1,2})\2\3$/

10.应用
1）获取urlhttps://www.baidu.com?name=james&age=28里age的值
  function getParamName(attr) {
    let search = window.location.search,
        match = RegExp(`[?&]${attr}=([^&]*)`).exec(search);
    return match && decodeURIComponent(match[1].trim());
  }    
  getParamName('age')//28

2）数字格式化问题
  let str = '1234567890'
  let format = str.replace(/\B(?=(\d{3})+(?!\d))/g, ',')
  console.log(format) // 1,234,567,890
  01 /\B(?=(\d{3})+(?!\d))/g：正则匹配边界\B，边界后面必须跟着(\d{3})+(?!\d);
  02 (\d{3})+：必须是1个或多个的3个连续数字;
  03 (?!\d)：第2步中的3个数字不允许后面跟着数字;
  04 (\d{3})+(?!\d)：所以匹配的边界后面必须跟着3*n（n>=1）的数字。

 

参考地址：
1.http://www.cnblogs.com/tugenhua0707/p/5037811.html
2.https://segmentfault.com/a/1190000009590458
3.https://github.com/jawil/blog/issues/20